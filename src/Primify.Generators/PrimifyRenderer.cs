namespace Primify.Generators;

public static class PrimifyRenderer
{
    public static string Render(PrimifyModel model)
    {
        var finalModifier = model.IsValueType ? "readonly" : "sealed";

        var equalityMembers = GenerateEqualityMembers(model);
        var toStringOverride = GenerateToStringOverride();
        var liteDbInitializer = GenerateLiteDbInitializer(model);
        var implicitCasting = GenerateImplicitCasting(model);
        var implicitExplicitCasting = GenerateImplicitExplicitCasting(model);

        return $$"""
                 // <auto-generated/>
                 #nullable enable

                 using System;
                 using System.Runtime.CompilerServices;
                 using LiteDB;
                 using Primify.Converters;

                 namespace {{model.Namespace}};

                 {{liteDbInitializer}}

                 [System.Text.Json.Serialization.JsonConverter(typeof(SystemTextJsonConverter<{{model.ClassName}}, {{model.WrapperArgument}}>))]
                 [Newtonsoft.Json.JsonConverter(typeof(NewtonsoftJsonConverter<{{model.ClassName}}, {{model.WrapperArgument}}>))]
                 [LiteDbSerializable]
                 {{finalModifier}} partial {{model.Keyword}} {{model.ClassName}} : IPrimify<{{model.ClassName}}, {{model.WrapperArgument}}>, IEquatable<{{model.ClassName}}>
                 {
                     public {{model.WrapperArgument}} Value { get; }
                     
                     private {{model.ClassName}}({{model.WrapperArgument}} value) => Value = value;

                     public static {{model.ClassName}} From({{model.WrapperArgument}} value)
                     {
                         var processedValue = value;

                         // Enable Normalize only when the user has an implementation
                         {{(model.HasNormalize ? "" : "// ")}}processedValue = Normalize(processedValue);
                         
                         // Enable Validate only when the user has an implementation
                         {{(model.HasValidate ? "" : "// ")}}Validate(processedValue);
                         
                         return new {{model.ClassName}}(processedValue);
                     }
                     
                 {{implicitCasting}}

                 {{implicitExplicitCasting}}
                     
                 {{toStringOverride}}

                 {{equalityMembers}}
                 }
                 """;
    }

    private static string GenerateEqualityMembers(PrimifyModel model)
    {
        var name = model.ClassName;
        var argument = model.WrapperArgument;

        if (model.IsRecord)
        {
            var equatableEquals = model.IsValueType
                ? $"public bool Equals({name} other)"
                : $"public bool Equals({name}? other)";

            return $$"""
                         public override int GetHashCode() => System.Collections.Generic.EqualityComparer<{{argument}}>.Default.GetHashCode(Value);

                         {{equatableEquals}}
                         {
                             {{(model.IsValueType ? "" : "if (other is null) return false;\n")}} return EqualityComparer<{{argument}}>.Default.Equals(Value, other.Value);
                         }
                     """;
        }

        if (model.IsValueType)
        {
            return $$"""
                         public override bool Equals(object? obj) => obj is {{name}} other && Equals(other);

                         public bool Equals({{name}} other)
                         {
                             return System.Collections.Generic.EqualityComparer<{{argument}}>.Default.Equals(Value, other.Value);
                         }

                         public override int GetHashCode() => System.Collections.Generic.EqualityComparer<{{argument}}>.Default.GetHashCode(Value);

                         public static bool operator ==({{name}} left, {{name}} right) => left.Equals(right);
                         public static bool operator !=({{name}} left, {{name}} right) => !(left == right);
                     """;
        }

        return $$"""
                     public override bool Equals(object? obj) => obj is {{name}} other && Equals(other);

                     public bool Equals({{name}}? other)
                     {
                         if (ReferenceEquals(null, other)) return false;
                         if (ReferenceEquals(this, other)) return true;
                        
                         return System.Collections.Generic.EqualityComparer<{{argument}}>.Default.Equals(Value, other.Value);
                     }

                     public override int GetHashCode() => System.Collections.Generic.EqualityComparer<{{argument}}>.Default.GetHashCode(Value);

                     public static bool operator ==({{name}}? left, {{name}}? right) =>
                         ReferenceEquals(left, right) || (left is not null && left.Equals(right));

                     public static bool operator !=({{name}}? left, {{name}}? right) => !(left == right);
                 """;
    }

    private static string GenerateToStringOverride() => "public override string ToString() => Value.ToString();";

    private static string GenerateImplicitExplicitCasting(PrimifyModel model) =>
        $"""
             public static implicit operator {model.ClassName}({model.WrapperArgument} value) => From(value);
             public static implicit operator {model.WrapperArgument}({model.ClassName} value) => value.Value;
         """;

    private static string GenerateImplicitCasting(PrimifyModel model)
    {
        string name = model.ClassName;
        string argument = model.WrapperArgument;
        string toBson;
        string fromBsonImplementation;

        switch (argument)
        {
            case "System.DateOnly":
                toBson = "new LiteDB.BsonValue(value.Value.ToDateTime(System.TimeOnly.MinValue))";
                fromBsonImplementation = $"=> {name}.From(System.DateOnly.FromDateTime(value.AsDateTime));";
                break;
            case "System.TimeOnly":
                toBson = "new LiteDB.BsonValue(value.Value.Ticks)";
                fromBsonImplementation = $"=> {name}.From(new System.TimeOnly(value.AsInt64));";
                break;
            case "System.DateTimeOffset":
                toBson = """
                         new LiteDB.BsonDocument { ["DateTime"] = value.Value.UtcDateTime, ["Offset"] = value.Value.Offset.Ticks }
                         """;
                fromBsonImplementation = $$"""
                                           {
                                               var doc = value.AsDocument;
                                               var utcDateTime = doc["DateTime"].AsDateTime;
                                               var offset = new System.TimeSpan(doc["Offset"].AsInt64);
                                               var utcTime = new System.DateTimeOffset(utcDateTime);
                                               var originalTime = utcTime.ToOffset(offset);
                                               return {{name}}.From(originalTime);
                                           }
                                           """;
                break;
            default:
                toBson = "new LiteDB.BsonValue(value.Value)";
                fromBsonImplementation =
                    $"=> {name}.From(({argument})System.Convert.ChangeType(value.RawValue, typeof({argument})));";
                break;
        }

        return $"""
                    public static implicit operator LiteDB.BsonValue({name} value) => {toBson};
                    public static implicit operator {name}(LiteDB.BsonValue value) {fromBsonImplementation}
                """;
    }

    private static string GenerateLiteDbInitializer(PrimifyModel model)
    {
        string name = model.ClassName;
        string argument = model.WrapperArgument;
        string serializeCode;
        string deserializeCode;

        switch (argument)
        {
            case "System.DateOnly":
                serializeCode = "wrapper => new LiteDB.BsonValue(wrapper.Value.ToDateTime(System.TimeOnly.MinValue))";
                deserializeCode = $"bson => {name}.From(System.DateOnly.FromDateTime(bson.AsDateTime))";
                break;
            case "System.TimeOnly":
                serializeCode = "wrapper => new LiteDB.BsonValue(wrapper.Value.Ticks)";
                deserializeCode = $"bson => {name}.From(new System.TimeOnly(bson.AsInt64))";
                break;
            case "System.DateTimeOffset":
                serializeCode = """
                                wrapper => new LiteDB.BsonDocument { ["DateTime"] = wrapper.Value.UtcDateTime, ["Offset"] = wrapper.Value.Offset.Ticks }
                                """;
                deserializeCode = $$"""
                                    bson => {
                                        var doc = bson.AsDocument;
                                        var utcDateTime = doc["DateTime"].AsDateTime;
                                        var offset = new System.TimeSpan(doc["Offset"].AsInt64);
                                        var utcTime = new System.DateTimeOffset(utcDateTime);
                                        var originalTime = utcTime.ToOffset(offset);
                                        return {{name}}.From(originalTime);
                                    }
                                    """;
                break;
            default:
                serializeCode = "wrapper => new LiteDB.BsonValue(wrapper.Value)";
                deserializeCode =
                    $"bson => {name}.From(({argument})System.Convert.ChangeType(bson.RawValue, typeof({argument})))";
                break;
        }

        return $$"""
                 file static class {{name}}LiteDbInitializer
                 {
                     [System.Runtime.CompilerServices.ModuleInitializer]
                     internal static void Register()
                     {
                         LiteDB.BsonMapper.Global.RegisterType<{{name}}>(
                             serialize: {{serializeCode}},
                             deserialize: {{deserializeCode}}
                         );
                     }
                 }
                 """;
    }
}
