namespace Primify.Generators;

public static class PrimifyRenderer
{
    public static string Render(PrimifyModel model)
    {
        var finalModifier = model.IsValueType ? "readonly" : "sealed";

        var equalityMembers = Indent(GenerateEqualityMembers(model));
        var implicitCasting = Indent(GenerateImplicitCasting(model));
        var implicitExplicitCasting = Indent(GenerateImplicitExplicitCasting(model));
        var liteDb = GenerateLiteDbInitializer(model);

        return $$"""
                 // <auto-generated/>
                 #nullable enable

                 using System;
                 using System.Runtime.CompilerServices;
                 using LiteDB;
                 using Primify.Converters;

                 namespace {{model.Namespace}};

                 {{liteDb}}

                 [System.Text.Json.Serialization.JsonConverter(typeof(SystemTextJsonConverter<{{model.ClassName}}, {{model.WrappedType}}>) )]
                 [Newtonsoft.Json.JsonConverter(typeof(NewtonsoftJsonConverter<{{model.ClassName}}, {{model.WrappedType}}>) )]
                 [LiteDbSerializable]
                 {{finalModifier}} partial {{model.Keyword}} {{model.ClassName}} : IPrimify<{{model.ClassName}}, {{model.WrappedType}}>, IEquatable<{{model.ClassName}}>
                 {
                     public {{model.WrappedType}} Value { get; }
                     
                     private {{model.ClassName}}({{model.WrappedType}} value) => Value = value;

                     public static {{model.ClassName}} From({{model.WrappedType}} value)
                     {
                         var processedValue = value;
                         {{(model.HasNormalize ? "" : "// ")}}processedValue = Normalize(processedValue);
                         {{(model.HasValidate ? "" : "// ")}}Validate(processedValue);
                         return new {{model.ClassName}}(processedValue);
                     }
                     
                     {{implicitCasting}}

                     {{implicitExplicitCasting}}
                     
                     public override string ToString() => Value.ToString();
                     
                     {{equalityMembers}}
                 }
                 """;
    }

    private static string Indent(string text)
    {
        if (string.IsNullOrEmpty(text)) return text;
        return text.Replace("\n", "\n    ");
    }

    private static string GenerateEqualityMembers(PrimifyModel model)
    {
        var name = model.ClassName;
        var arg = model.WrappedType;
        var (equalsExpr, hashCodeExpr) = GetEqualityExpressions(arg);

        // For record types, let the compiler generate optimized equality
        // Record types already have compiler-generated equality that's highly optimized
        if (model.IsRecord)
        {
            return string.Empty;
        }

        if (model.IsValueType)
        {
            return $$"""
                     public override bool Equals(object? obj) => obj is {{name}} other && Equals(other);

                     public bool Equals({{name}} other)
                     {
                         return {{equalsExpr("Value", "other.Value")}};
                     }

                     public override int GetHashCode() => {{hashCodeExpr("Value")}};

                     public static bool operator ==({{name}} left, {{name}} right) => left.Equals(right);
                     public static bool operator !=({{name}} left, {{name}} right) => !(left == right);
                     """;
        }

        return $$"""
                 public override bool Equals(object? obj) => obj is {{name}} other && Equals(other);

                 public bool Equals({{name}}? other)
                 {
                     if (ReferenceEquals(null, other)) return false;
                     if (ReferenceEquals(this, other)) return true;
                     return {{equalsExpr("Value", "other.Value")}};
                 }

                 public override int GetHashCode() => {{hashCodeExpr("Value")}};

                 public static bool operator ==({{name}}? left, {{name}}? right) => ReferenceEquals(left, right) || (left is not null && left.Equals(right));
                 public static bool operator !=({{name}}? left, {{name}}? right) => !(left == right);
                 """;
    }

    private static (Func<string, string, string> equalsExpr, Func<string, string> hashCodeExpr) GetEqualityExpressions(string wrappedType)
    {
        // For strings, use direct comparison for better performance
        if (wrappedType == "string" || wrappedType == "System.String")
        {
            return (
                (left, right) => $"string.Equals({left}, {right}, System.StringComparison.Ordinal)",
                value => $"{value}?.GetHashCode() ?? 0"
            );
        }

        // For primitive value types, use direct == operator
        if (IsPrimitiveValueType(wrappedType))
        {
            return (
                (left, right) => $"{left} == {right}",
                value => $"{value}.GetHashCode()"
            );
        }

        // For other types, fall back to EqualityComparer.Default
        return (
            (left, right) => $"System.Collections.Generic.EqualityComparer<{wrappedType}>.Default.Equals({left}, {right})",
            value => $"System.Collections.Generic.EqualityComparer<{wrappedType}>.Default.GetHashCode({value})"
        );
    }

    private static bool IsPrimitiveValueType(string type)
    {
        return type switch
        {
            "int" or "System.Int32" => true,
            "long" or "System.Int64" => true,
            "short" or "System.Int16" => true,
            "byte" or "System.Byte" => true,
            "bool" or "System.Boolean" => true,
            "char" or "System.Char" => true,
            "double" or "System.Double" => true,
            "float" or "System.Single" => true,
            "decimal" or "System.Decimal" => true,
            "Guid" or "System.Guid" => true,
            "DateTime" or "System.DateTime" => true,
            "DateTimeOffset" or "System.DateTimeOffset" => true,
            "DateOnly" or "System.DateOnly" => true,
            "TimeOnly" or "System.TimeOnly" => true,
            "TimeSpan" or "System.TimeSpan" => true,
            _ => false
        };
    }

    private static string GenerateImplicitExplicitCasting(PrimifyModel model) =>
        $$"""
          public static implicit operator {{model.ClassName}}({{model.WrappedType}} value) => From(value);
          public static implicit operator {{model.WrappedType}}({{model.ClassName}} value) => value.Value;
          """;

    private static string GenerateImplicitCasting(PrimifyModel model)
    {
        string name = model.ClassName;
        string arg = model.WrappedType;
        string toBson;
        string fromBsonImplementation;

        switch (arg)
        {
            case "System.DateOnly":
                toBson = "new LiteDB.BsonValue(value.Value.ToDateTime(System.TimeOnly.MinValue))";
                fromBsonImplementation = $"=> {name}.From(System.DateOnly.FromDateTime(value.AsDateTime));";
                break;

            case "System.TimeOnly":
                toBson = "new LiteDB.BsonValue(value.Value.Ticks)";
                fromBsonImplementation = $"=> {name}.From(new System.TimeOnly(value.AsInt64));";
                break;

            case "System.DateTimeOffset":
                toBson = """
                         new LiteDB.BsonDocument
                         {
                             ["DateTime"] = value.Value.UtcDateTime,
                             ["Offset"] = value.Value.Offset.Ticks
                         }
                         """;

                // We must indent the multi-line body correctly
                fromBsonImplementation = $$"""
                                           {
                                                   var doc = value.AsDocument;
                                                   var utcDateTime = doc["DateTime"].AsDateTime;
                                                   var offset = new System.TimeSpan(doc["Offset"].AsInt64);

                                                   // Create a UTC DateTimeOffset first, then convert to the original offset
                                                   var utcTime = new System.DateTimeOffset(utcDateTime);
                                                   var originalTime = utcTime.ToOffset(offset);

                                                   return {{name}}.From(originalTime);
                                               }
                                           """;
                break;

            default:
                toBson = "new LiteDB.BsonValue(value.Value)";
                fromBsonImplementation =
                    $"=> {name}.From(({arg})System.Convert.ChangeType(value.RawValue, typeof({arg})));";
                break;
        }

        return $$"""
                 // Casting for BSON
                 public static implicit operator LiteDB.BsonValue({{name}} value) => {{toBson}};
                 public static implicit operator {{name}}(LiteDB.BsonValue value) {{fromBsonImplementation}}
                 """;
    }

    private static string GenerateLiteDbInitializer(PrimifyModel model)
    {
        string name = model.ClassName;
        string arg = model.WrappedType;
        string serializeCode;
        string deserializeCode;

        switch (arg)
        {
            case "System.DateOnly":
                serializeCode = "wrapper => new LiteDB.BsonValue(wrapper.Value.ToDateTime(System.TimeOnly.MinValue))";
                deserializeCode = $"bson => {name}.From(System.DateOnly.FromDateTime(bson.AsDateTime))";
                break;

            case "System.TimeOnly":
                serializeCode = "wrapper => new LiteDB.BsonValue(wrapper.Value.Ticks)";
                deserializeCode = $"bson => {name}.From(new System.TimeOnly(bson.AsInt64))";
                break;

            case "System.DateTimeOffset":
                // We format this manually to look decent in the generated file
                serializeCode = """
                                wrapper => new LiteDB.BsonDocument
                                    {
                                        ["DateTime"] = wrapper.Value.UtcDateTime,
                                        ["Offset"] = wrapper.Value.Offset.Ticks
                                    }
                                """;

                deserializeCode = $$"""
                                    bson => 
                                        {
                                            var doc = bson.AsDocument;
                                            var utcDateTime = doc["DateTime"].AsDateTime;
                                            var offset = new System.TimeSpan(doc["Offset"].AsInt64);
                                            var utcTime = new System.DateTimeOffset(utcDateTime);
                                            var originalTime = utcTime.ToOffset(offset);
                                            return {{name}}.From(originalTime);
                                        }
                                    """;
                break;

            default:
                serializeCode = "wrapper => new LiteDB.BsonValue(wrapper.Value)";
                deserializeCode =
                    $"bson => {name}.From(({arg})System.Convert.ChangeType(bson.RawValue, typeof({arg})))";
                break;
        }

        return $$"""
                 file static class {{name}}LiteDbInitializer
                 {
                     [System.Runtime.CompilerServices.ModuleInitializer]
                     internal static void Register()
                     {
                         LiteDB.BsonMapper.Global.RegisterType<{{name}}>(
                             serialize: {{serializeCode}},
                             deserialize: {{deserializeCode}}
                         );
                     }
                 }
                 """;
    }
}
